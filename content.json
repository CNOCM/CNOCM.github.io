{"meta":{"title":"CNOCM","subtitle":"","description":"宁静致远","author":"CNOCM","url":"https://cnocm.github.io","root":"/"},"pages":[{"title":"","date":"2023-08-28T06:46:52.201Z","updated":"2023-08-28T06:46:52.201Z","comments":true,"path":"404.html","permalink":"https://cnocm.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2023-08-28T07:46:54.083Z","updated":"2023-08-28T07:46:54.083Z","comments":true,"path":"about/index.html","permalink":"https://cnocm.github.io/about/index.html","excerpt":"","text":"正在施工…"},{"title":"所有分类","date":"2023-08-28T06:49:22.730Z","updated":"2023-08-28T06:49:22.730Z","comments":true,"path":"categories/index.html","permalink":"https://cnocm.github.io/categories/index.html","excerpt":"","text":"正在施工…"},{"title":"","date":"2023-08-28T07:18:07.686Z","updated":"2023-08-28T07:18:07.686Z","comments":true,"path":"friends/index.html","permalink":"https://cnocm.github.io/friends/index.html","excerpt":"","text":"正在施工…"},{"title":"所有标签","date":"2023-08-28T06:49:25.204Z","updated":"2023-08-28T06:49:25.204Z","comments":true,"path":"tags/index.html","permalink":"https://cnocm.github.io/tags/index.html","excerpt":"","text":"正在施工…"}],"posts":[{"title":"OpenWrt 定时关闭 LED 灯","slug":"OpenWrt定时关闭LED灯","date":"2023-09-06T04:11:55.000Z","updated":"2023-09-10T15:13:28.535Z","comments":true,"path":"posts/56301/","link":"","permalink":"https://cnocm.github.io/posts/56301/","excerpt":"","text":"前段时间，为了解决校园网限制设备的问题。入手了一个Xiaomi Mi Router 3G，到手后立马刷入了 OpenWRT ，并设置了自动认证和防检测。 然而到了第一天晚上就发现一个问题：寝室熄灯后LED灯太亮，正困的时候，灯光直射你的眼睛，你还睡不睡。 无解，便开始寻找解决方案，能不能关掉着破灯：白天亮起，晚上熄灭。 找到了脚本，LED 由 /sys/class/leds 目录下的配置文件控制，写入不同的值来控制 LED 灯的点亮和熄灭，0 值为关闭，3 为开启，写入立即生效。 新建一个脚本用于控制 LED 熄灭，我将他存放在 /etc/off_leds.sh。 1vim /etc/off_leds.sh 1234567#!/bin/shfor i in `ls /sys/class/leds`do cd /sys/class/leds cd $i echo 0 &gt; brightnessdone 给它个执行权限，然后执行： 12chmod a+x /etc/off_leds.sh/etc/off_leds.sh 再将它加入定时任务，LED 灯开启可以通过初始化 LED 的脚本实现： 12# 关闭 LED 灯 每晚23:3030 23 * * * /etc/off_leds.sh 到点熄灭了。 因为周天至周四晚23:00会断网，我又不想每次都关闭手机的WIFI，所以想着能不能到点就禁用WIFI信号。 新建一个脚本用于控制 WIFI禁用，我将他存放在 /etc/off_WIFI.sh。 1vim /etc/off_WIFI.sh 1234567891011121314151617181920212223#!/bin/sh# 获取当前日期和时间current_day=$(date +%u) # 获取当前星期几（1-7，1表示星期一，7表示星期天）current_time=$(date +%H:%M) # 获取当前时间，格式为时:分，例如09:30# 检查是否需要禁用WiFishould_disable_wifi() &#123; if [ &quot;$current_day&quot; -eq 7 ] || ([ &quot;$current_day&quot; -ge 1 ] &amp;&amp; [ &quot;$current_day&quot; -le 4 ]); then # 如果今天是周日或周一到周四 if [[ &quot;$current_time&quot; &gt; &quot;23:00&quot; ]]; then # 如果当前时间晚于23:00 return 0 # 返回0表示需要禁用WiFi fi fi return 1 # 返回1表示不需要禁用WiFi&#125;# 检查是否需要禁用WiFiif should_disable_wifi; then kill -9 $(pgrep -f &quot;/etc/autoshell.sh&quot;) 2&gt;/dev/null # 停止自动认证脚本 wifi down # 禁用WiFielse wifi up # 启用WiFifi 给它个执行权限，然后执行： 12chmod a+x /etc/off_WIFI.sh/etc/off_WIFI.sh 再将它加入定时任务，LED 灯开启可以通过初始化 LED 的脚本实现： 12# 禁用WIFI 每晚23:1010 23 * * * /etc/off_WIFI.sh 最后再使用自动重启功能，定为早晨6点（校园网6点开启）。 体验非常舒适，晚上再也没有瞎眼的灯了，也不用我关闭手机WIFI了，第二天起床也能自动连接。","categories":[],"tags":[],"author":"CNOCM"},{"title":"git clone加速","slug":"为git添加代理","date":"2023-08-24T04:49:39.000Z","updated":"2023-08-28T08:34:35.561Z","comments":true,"path":"posts/27210/","link":"","permalink":"https://cnocm.github.io/posts/27210/","excerpt":"","text":"当在克隆或从远程仓库获取数据时，很可能因为网络状况不佳遇到很慢甚至超时的情况，那么此时您可能需要配置 Git 的代理。 第一种：使用镜像站最常见 GitHub 镜像地址：https://gitclone.com/https://hub.fastgit.org/https://github.com.cnpmjs.org/访问上面的镜像网站，网站的内容跟 GitHub 是完整同步的镜像，然后在这个网站里面进行下载克隆等操作。举个栗子： git clone https://github.com/microsoft/vscode.git替换为 ：git clone https://gitclone.com/github.com/microsoft/vscode 第二种 设置git参数12git config --global url.&quot;https://gitclone.com/&quot;.insteadOf https://git clone https://github.com/microsoft/vscode.git 第三种 使用cgit工具下载链接：https://github.com/git-cloner/gitcache/releases 1cgit clone https://github.com/microsoft/vscode.git 第四种 使用本地代理12345678# 设置代理git config --global http.proxy &lt;protocol&gt;://&lt;host&gt;:&lt;port&gt;*--glboal 选项指的是修改 Git 的全局配置文件 ~/.gitconfig（而非各个 Git 仓库里的配置文件 .git/config）。*&lt;protocol&gt; 指的是代理协议，如 http，https，socks5 等。*&lt;host&gt; 为代理主机，如使用本地代理主机 127.0.0.1 或 localhost 等。*&lt;port&gt; 则为代理端口号，如 clash 使用的 7890 或 7891 等。# 取消代理git config --global --unset http.proxy","categories":[],"tags":[],"author":"CNOCM"},{"title":"记录使用Python登录某大学教务系统","slug":"教务系统登录模拟","date":"2023-06-25T04:49:39.000Z","updated":"2023-09-15T13:38:54.124Z","comments":true,"path":"posts/18252/","link":"","permalink":"https://cnocm.github.io/posts/18252/","excerpt":"","text":"本文章仅用作于学习 背景：最近期末到来，想第一时间看到新出成绩的，但教务系统处必须得等到学期结束才能看到，于是就有了想到爬取学校教务系统来获取自己的成绩，目前完成了模拟登录的阶段。因为大部分网站都可以通过CAS进行授权登录，所以只要登录了，就可以方便地完成一些机械化的操作。可以导出课表、成绩单、抢课。之后有时间的话，可以补充一些真正有用的应用。 目录 - 新教务系统 - 旧教务系统 新教务系统分析登录请求首先进入新教务系统首页，打开F12，输入账号密码进行测试。提交的表单数据如下： 可以看到，username就是学号，password不是密码的明文，可能是经过了哈希或者加密，authcode是图片验证码，_eventId 应该是提交的意思，而最长的execution看不出有什么含义。通过查看网页源代码，可以看到登录表单中有一项 就是execution的内容，可以看出，每次请求页面的时候会返回execution，在登录时带着这一项提交，作用可能是防止csrf攻击（猜的）。 那么就只剩下密码这一个参数了。如果前端通过js加密密码，必然要先从input框中先获取密码的内容，于是先找到密码框的html代码然后在source中全文搜索password关键字，发现login.js中有一段这样的代码 可以看到这段代码先进行一些字段检查，再把密码加密填写回`password`，最后再执行submit提交到后台。 继续搜索加密中用到的`RSAUtils` 再观察到201行，需要传入public_exponent和Modulus作为参数，继续搜索也找到了来源，是向v2&#x2F;getPubKey发送请求后得到。 然而多次尝试后都无法登录，遂暂时放弃此方法。 8.30更新 在对整个登录过程完整抓包分析后，发现了部分遗漏的参数，即post提交时v的值。同样使用搜索后，发现也是在网页源代码中同时,在每次发送请求时都会携带第一次访问时返回的cookies 9.2更新 多次尝试后，都会重定向到学校的信息门户，而不是强智的教务系统又经过一番分析，重定向的url收到最开始的service影响所以需要加上params。最后从response.history里找到最后的重定向url。 代码实现至此，整个登录的流程已经梳理清楚了，开始使用代码实现 1.先访问页面并提取execution和v 12345678url = &quot;https://cas.xxx.edu.cn/lyuapServer/login&quot;params = &#123; &quot;service&quot;: &quot;https://jw.xxx.edu.cn/&quot;&#125;response = requests.get(url,params=params)execution = re.search(r&#x27;name=&quot;execution&quot; value=&quot;(.*?)&quot;&#x27;, response.text).group(1)v_value = re.search(r&#x27;action=&quot;.*\\?v=(.*)&quot;\\s&#x27;, response.text).group(1)cookies = response.cookies.get_dict() 2.获取密码加密需要的参数及加密密码 1234567891011121314151617181920212223def get_public_key(): url = &quot;https://cas.xxx.edu.cn/lyuapServer/v2/getPubKey&quot; try: response = requests.get(url,cookies=cookies) modulus = response.json()[&#x27;modulus&#x27;] public_exponent = response.json()[&#x27;exponent&#x27;] cookies_pv0 = response.cookies.get_dict() return modulus, exponent, cookies_pv0 except requests.exceptions.RequestException as e: print(&quot;Error: &quot;, e)def encrypt_password(public_exponent, modulus, password): password_bytes = bytes(password, &#x27;ascii&#x27;) password_int = int.from_bytes(password_bytes, &#x27;big&#x27;) e_int = int(public_exponent, 16) m_int = int(modulus, 16) result_int = pow(password_int, e_int, m_int) encrypted_password = hex(result_int)[2:].rjust(128, &#x27;0&#x27;) return encrypted_passwordmodulus, public_exponent, cookies_pv0 = get_public_key()encrypted_password = encrypt_password(public_exponent, modulus, password) 3.获取图片验证码 1234567891011121314151617181920def get_captcha(): timestamp = int(time.time()* 1000) url = &quot;https://cas.xxx.edu.cn/lyuapServer/kaptcha&quot; params = &#123; &quot;_&quot;: timestamp, &#125; try: response = requests.get(url, params=params, cookies=cookies) if response.status_code == 200: save_path = &quot;captcha.png&quot; with open(save_path, &#x27;wb&#x27;) as file: file.write(response.content) print(&quot;图片已保存：&quot;, save_path) authcode = input(&quot;请输入验证码：&quot;) return authcode else: print(&quot;无法获取图片：&quot;, url) except Exception as e: print(&quot;错误：&quot;, e) 4.发送登录请求 12345678910111213cookies = &#123;**cookies, **cookies_pv0&#125;url = &quot;https://cas.xxx.edu.cn/lyuapServer/login&quot;params = &#123; &quot;v&quot;: v_value,&#125;data = &#123; &#x27;username&#x27;: username, &#x27;password&#x27;: encrypted_password, &#x27;authcode&#x27;: authcode, &#x27;execution&#x27;: execution, &#x27;_eventId&#x27;: &#x27;submit&#x27;&#125;response = requests.post(url, params=params, data=data, cookies=cookies) 5.重定向到教务系统 123456cookies = response.history[3].cookiesurl = &quot;https://jw.xxx.edu.cn/jsxsd/framework/xsMain_new.jsp&quot;params = &#123; &quot;t1&quot; : &quot;1&quot;&#125;response = requests.get(url, cookies=cookies, params=params) 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import requestsimport reimport timeurl = &quot;https://cas.xxx.edu.cn/lyuapServer/login&quot;params = &#123; &quot;service&quot;: &quot;https://jw.xxx.edu.cn/&quot;&#125;response = requests.get(url,params=params)execution = re.search(r&#x27;name=&quot;execution&quot; value=&quot;(.*?)&quot;&#x27;, response.text).group(1)v_value = re.search(r&#x27;action=&quot;.*\\?v=(.*)&quot;\\s&#x27;, response.text).group(1)cookies = response.cookies.get_dict()def get_public_key(): url = &quot;https://cas.xxx.edu.cn/lyuapServer/v2/getPubKey&quot; try: response = requests.get(url,cookies=cookies) modulus = response.json()[&#x27;modulus&#x27;] public_exponent = response.json()[&#x27;exponent&#x27;] cookies_pv0 = response.cookies.get_dict() return modulus, public_exponent, cookies_pv0 except requests.exceptions.RequestException as e: print(&quot;Error: &quot;, e)def encrypt_password(public_exponent, modulus, password): password_bytes = bytes(password, &#x27;ascii&#x27;) password_int = int.from_bytes(password_bytes, &#x27;big&#x27;) e_int = int(public_exponent, 16) m_int = int(modulus, 16) result_int = pow(password_int, e_int, m_int) encrypted_password = hex(result_int)[2:].rjust(128, &#x27;0&#x27;) return encrypted_passworddef get_captcha(): timestamp = int(time.time()* 1000) url = &quot;https://cas.xxx.edu.cn/lyuapServer/kaptcha&quot; params = &#123; &quot;_&quot;: timestamp, &#125; try: response = requests.get(url, params=params, cookies=cookies) if response.status_code == 200: save_path = &quot;captcha.png&quot; with open(save_path, &#x27;wb&#x27;) as file: file.write(response.content) print(&quot;图片已保存：&quot;, save_path) authcode = input(&quot;请输入验证码：&quot;) return authcode else: print(&quot;无法获取图片：&quot;, url) except Exception as e: print(&quot;错误：&quot;, e)username = &#x27;&#x27; # 填入你的用户名password = &#x27;&#x27; # 填入你的密码modulus, public_exponent, cookies_pv0 = get_public_key()authcode = get_captcha()encrypted_password = encrypt_password(public_exponent, modulus, password)cookies = &#123;**cookies, **cookies_pv0&#125;url = &quot;https://cas.xxx.edu.cn/lyuapServer/login&quot;params = &#123; &quot;v&quot;: v_value,&#125;data = &#123; &#x27;username&#x27;: username, &#x27;password&#x27;: encrypted_password, &#x27;authcode&#x27;: authcode, &#x27;execution&#x27;: execution, &#x27;_eventId&#x27;: &#x27;submit&#x27;&#125;response = requests.post(url, params=params, data=data, cookies=cookies)# 强智cookies = response.history[3].cookiesurl = &quot;https://jw.xxx.edu.cn/jsxsd/framework/xsMain_new.jsp&quot;params = &#123; &quot;t1&quot; : &quot;1&quot;&#125;response = requests.get(url, cookies=cookies, params=params) 旧教务系统偶然发现在教务系统退出后会被重定向到旧版的教务系统处，似乎所有强智教务都有这个入口。输入账号密码进行登录————失败。提示 用户名或密码错误，————忘记密码也不可使用。提示 该帐号没有设置密码找回信息，无法完成该操作！ 8.30更新尝试了众多密码后，我意识到，也许旧教务系统内储存的密码可能和OA系统内的不一致，于是我去学校网站上搜索新教务系统，有了一些眉目。关于征集正方教务系统使用意见的通知软件集成服务-信息化办公室教务处召开学期选课工作视频协调会根据这些信息，我推测我校在16年之前都是使用的正方教务，在17年更换了强智教务，随后又在20年引入OA系统。 9.3更新根据上述推测，我认为在引入OA系统后，旧教务系统可能没有及时更新，储存的是默认密码。而教职工及学校的学工号都是进校年份，我觉得20年之后入学的都为默认密码。经测试，的确和我想的一样，以2020打头的学工号都可以用默认密码登录。 分析登录请求不妨大胆猜测，旧教务系统的默认密码就是学号。成功登入，并进入修改密码页面。的确，在修改密码之后，可以绕过OA系统，直接进入教务系统。 至此，剩下的内容就比较简单了。同样打开F12，输入账号密码进行测试。会看见userAccount和encoded被提交到了一个LoginToXk的接口，提交的数据也就只有账号密码，账号明文而encoded暂不知，猜测是某种加密，好在加密方式比较好找，源代码里直接就能找到。定位到函数位置。 12345678910111213141516171819202122232425var keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;function encodeInp(input) &#123; var output = &quot;&quot;; var chr1, chr2, chr3 = &quot;&quot;; var enc1, enc2, enc3, enc4 = &quot;&quot;; var i = 0; do &#123; chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) &#123; enc3 = enc4 = 64 &#125; else if (isNaN(chr3)) &#123; enc4 = 64 &#125; output = output + keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4); chr1 = chr2 = chr3 = &quot;&quot;; enc1 = enc2 = enc3 = enc4 = &quot;&quot; &#125; while (i &lt; input.length); return output&#125; 明显，这是一个base64编码。然后encoded也在下方做了说明var encoded = account + &quot;%%%&quot; + passwd;, 代码实现所以直接写个函数，将encoded进行base64编码，然后返回。 123456789101112import base64def encodeInp(input): encoded_bytes = base64.b64encode(input.encode(&#x27;utf-8&#x27;)) output = encoded_bytes.decode(&#x27;utf-8&#x27;) return outputdef encode(xh, psw): account = encodeInp(xh) passwd = encodeInp(psw) encoded = account + &quot;%%%&quot; + passwd return encoded 接下来简单写个请求就完成了。 1234567891011121314151617url = &quot;https://jw.xxx.edu.cn/jsxsd/&quot;response = requests.get(url)cookies = response.cookies.get_dict()xh = input(&quot;账号：&quot;)psw = input(&quot;密码：&quot;)encoded = encode(xh, psw)url = &quot;https://jw.xxx.edu.cn/jsxsd/xk/LoginToXk&quot;data = &#123; &quot;userAccount&quot;: xh, &quot;userPassword&quot;: &quot;&quot;, &quot;encoded&quot;: encoded, &quot;pwdstr1&quot;: &quot;&quot;, &quot;pwdstr2&quot;: &quot;&quot;,&#125;response = requests.post(url, data=data, cookies=cookies) 至此，教务系统的模拟登录就结束了。","categories":[],"tags":[],"author":"CNOCM"}],"categories":[],"tags":[]}